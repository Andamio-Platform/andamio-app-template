---
title: "Utilities"
description: "CBOR decoder and helper utilities"
icon: Wrench
---

# Utilities

The `@andamio/transactions` package includes utilities for decoding transaction CBOR and formatting complex inputs.

## Hash Utilities (Migrated)

**Note:** Hash utilities have been migrated to the main T3 App Template at `~/lib/utils/`:

| Function | New Location |
|----------|--------------|
| `computeSltHashDefinite` | `~/lib/utils/slt-hash.ts` |
| `computeAssignmentInfoHash` | `~/lib/utils/assignment-info-hash.ts` |
| `computeTaskHash` | `~/lib/utils/task-hash.ts` |

```typescript
// New import pattern in T3 App Template
import { computeSltHashDefinite } from "~/lib/utils/slt-hash";
import { computeAssignmentInfoHash } from "~/lib/utils/assignment-info-hash";
import { computeTaskHash } from "~/lib/utils/task-hash";
```

---

## CBOR Transaction Decoder

Decode Cardano transaction CBOR to extract mints, outputs, inputs, and metadata. Uses `@meshsdk/core-cst` under the hood.

### Who Uses This

The **frontend (T3 App Template)** is the primary user. The transaction API returns `unsignedTxCBOR` in its response - this decoder lets the frontend inspect what's in it before asking the user to sign.

**Who Does NOT Need This:**
- **Transaction API** - It builds the CBOR, doesn't need to decode it
- **DB API** - Only handles database records, never touches CBOR
- **Transaction Monitoring Service** - Would query Koios/Blockfrost for confirmed tx data

### decodeTransactionCbor

Full transaction decode for preview UI:

```typescript
import { decodeTransactionCbor } from "@andamio/transactions";

const { unsignedTxCBOR } = await txApiResponse.json();

const decoded = decodeTransactionCbor(unsignedTxCBOR);

console.log(`Fee: ${Number(decoded.fee) / 1_000_000} ADA`);
console.log(`Minting ${decoded.mints.length} tokens`);
console.log(`Outputs:`, decoded.outputs);
console.log(`Inputs:`, decoded.inputs);
```

### extractMints

Extract just the mints from a transaction:

```typescript
import { extractMints } from "@andamio/transactions";

const mints = extractMints(unsignedTxCBOR);
// => [{ policyId: "abc...", assetName: "moduleHash...", quantity: 1n }]
```

### extractMintsByPolicy

Filter mints by policy ID:

```typescript
import { extractMintsByPolicy } from "@andamio/transactions";

const moduleMints = extractMintsByPolicy(unsignedTxCBOR, modulePolicy);
```

### extractAssetNames

Get just asset names (useful for module hashes):

```typescript
import { extractAssetNames } from "@andamio/transactions";

const moduleHashes = extractAssetNames(unsignedTxCBOR, modulePolicy);
// => ["8dcbe1b...", "a2f3c4d..."]
```

### extractTxId

Get the transaction ID:

```typescript
import { extractTxId } from "@andamio/transactions";

const txId = extractTxId(unsignedTxCBOR);
```

### Practical Reality

For most Andamio transactions, the decoder is a **nice-to-have** rather than essential:

- Module hashes can be pre-computed with `computeSltHashDefinite(slts)` before calling the tx API
- Evidence hashes are computed with `computeAssignmentInfoHash(evidence)` before submission
- Transaction ID comes back after signing

The decoder is most valuable for **transaction preview UI** and **debugging**.

---

## Batch Module Management Helpers

For `COURSE_TEACHER_MODULES_MANAGE`, helper functions format request bodies for batch operations.

### formatBatchUpdateStatusBody

Format body for setting modules to PENDING_TX:

```typescript
import { formatBatchUpdateStatusBody } from "@andamio/transactions";

const updateBody = formatBatchUpdateStatusBody(
  courseNftPolicyId,           // "abc123..."
  ["MODULE_1", "MODULE_2"],    // module codes being managed
  txHash                       // from wallet.submitTx()
);

await fetch('/api/course-modules/batch-update-status', {
  method: 'POST',
  body: JSON.stringify(updateBody),
});
```

### formatBatchConfirmBody

Format body for confirming modules with hashes:

```typescript
import { formatBatchConfirmBody } from "@andamio/transactions";
import { computeSltHashDefinite } from "~/lib/utils/slt-hash";

// Pre-compute hashes (preferred - known at submission time)
const moduleHashes = modules.map(m => computeSltHashDefinite(m.slts.map(s => s.text)));

const confirmBody = formatBatchConfirmBody(
  courseNftPolicyId,           // "abc123..."
  ["MODULE_1", "MODULE_2"],    // module codes (same order as minting)
  txHash,                      // confirmed transaction hash
  moduleHashes                 // array of module hashes (same order)
);

await fetch('/api/course-modules/batch-confirm-transaction', {
  method: 'POST',
  body: JSON.stringify(confirmBody),
});
```

**Important:** Module codes and hashes must be passed in the same order as they appear in `module_infos`.

---

## Related Documentation

- [Getting Started](/docs/sdk/transactions/getting-started) - Basic usage
- [V2 Transactions](/docs/sdk/transactions/v2) - Transaction reference
- [Side Effects](/docs/sdk/transactions/side-effects) - Database update patterns
